---
layout: post
title: "Masking PII with Ruby gsub with Regular Expression Named Match Groups, Non-Greedy"
date: 2015-01-25 10:51:48 -1000
comments: true
categories: 
keywords: 
description: 
---


<p>
In this article, you'll learn:
</p>

<ol class="org-ol">
<li>How to effectively use <a href="http://rubular.com/">rubular.com</a> and the Ruby console to get the correct
regular expression syntax.
</li>
<li>What is the difference between <code>.*</code> and <code>.*?</code>, greedy and non-greedy.
</li>
<li>What are regular expression named capture groups and why you should use them.
</li>
<li>How to use String#gsub without and with the block syntax, and without or with
named capture groups.
</li>
</ol>

<p>
Suppose you have to filter out <a href="http://en.wikipedia.org/wiki/Personally_identifiable_information">PII (Personally Identifiable Information)</a> out of
log entries that look like this HTML. We don't want the following PII fields to
show their values: <code>email</code>, <code>social_security_number</code>, <code>date_of_birth</code>
</p>

<p>
<b><i>Input Html</i></b>
</p>
{% codeblock lang:HTML %}
Updated User (4)<br>
     changed first_name to &quot;Karina&quot;<br>
     changed last_name to &quot;Senger&quot;<br>
     changed phone to &quot;2133432154&quot;<br>
     changed email to &quot;brenna.treutel@runolfsdottirdonnelly.org&quot;<br>
     changed street to &quot;123 Main St&quot;<br>
     changed city to &quot;Paia&quot;<br>
     changed state to &quot;HI&quot;<br>
     changed zip_code to &quot;96677&quot;<br>
     changed social_security_number to &quot;555-33-4444&quot;<br>
     changed date_of_birth to &quot;2000-10-03&quot;
{% endcodeblock %}

<p>
And the end result we want is:
</p>
{% codeblock lang:HTML %}
Updated User (4)<br>
     changed first_name to &quot;Karina&quot;<br>
     changed last_name to &quot;Senger&quot;<br>
     changed phone to &quot;2133432154&quot;<br>
     changed email to XXXXXX<br>
     changed street to &quot;123 Main St&quot;<br>
     changed city to &quot;Paia&quot;<br>
     changed state to &quot;HI&quot;<br>
     changed zip_code to &quot;96677&quot;<br>
     changed social_security_number to XXXXXX<br>
     changed date_of_birth to XXXXXX
{% endcodeblock %}

<!-- more -->

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Reference Web Pages</h2>
<div class="outline-text-2" id="text-1">
<p>
I suggest you open the following reference web pages:
</p>
<ol class="org-ol">
<li>Ruby doc for <a href="http://ruby-doc.org/core-2.1.5/Regexp.html">Class Regexp</a>
</li>
<li>Ruby doc for <a href="http://ruby-doc.org/core-2.1.5/String.html#method-i-replace">String#gsub</a>
</li>
<li>Interactive Ruby regular expression tester: <a href="http://rubular.com/">rubular.com</a>
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Figure out the Regexp</h2>
<div class="outline-text-2" id="text-2">
<p>
First, let's figure out the right regular expression using <a href="http://rubular.com/">rubular.com</a>.
</p>
</div>

<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">Basic Regexp</h3>
<div class="outline-text-3" id="text-2-1">
<p>
Copy the above string of input (gray box above labeled /Input HTML/into the "Your test string" box, and then let's figure
out a simple regexp to match an individual line.
</p>

<pre class="example">
changed email to &amp;quot;(.*?)&amp;quot;
</pre>

<p>
{% img /images/2015-01-25-masking-pii-with-ruby-gsub-with-regular-expression-named-match-groups/rubular-1.jpg %}
</p>
</div>
</div>
<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">Why the (.*?) or Why Non-Greedy</h3>
<div class="outline-text-3" id="text-2-2">
<p>
The <code>.*?</code> syntax means to get the non-greedy match. In order to see this, let's
use this string below into the "Your test string" box (note, the text scrolls
way to the right):
</p>

{% codeblock lang:HTML %}
Updated User (4)<br>     changed first_name to &quot;Karina&quot;<br>     changed last_name to &quot;Senger&quot;<br>     changed phone to &quot;2133432154&quot;<br>     changed email to &quot;brenna.treutel@runolfsdottirdonnelly.org&quot;<br>     changed street to &quot;123 Main St&quot;<br>     changed city to &quot;Paia&quot;<br>     changed state to &quot;HI&quot;<br>     changed zip_code to &quot;96677&quot;<br>     changed social_security_number to &quot;555-33-4444&quot;<br>   changed date_of_birth to &quot;2000-10-03&quot;
{% endcodeblock %}

<p>
Notice that you see the correct result for the match.
</p>

<p>
Now, remove the <code>?</code> in the <code>.*?</code>, using this regexp:
</p>

<pre class="example">
changed email to &amp;quot;(.*)&amp;quot;
</pre>

<p>
And you'll see this:
</p>

<p>
{% img /images/2015-01-25-masking-pii-with-ruby-gsub-with-regular-expression-named-match-groups/rubular-2.jpg %}
</p>

<p>
Now, add back the <code>?</code> after the <code>.*</code>, and you'll see the right value.
</p>

<p>
{% img /images/2015-01-25-masking-pii-with-ruby-gsub-with-regular-expression-named-match-groups/rubular-3.jpg %}
</p>

<p>
The Ruby docs for <a href="http://ruby-doc.org/core-2.1.5/Regexp.html">Class Regexp</a> explain this:
</p>

<blockquote>
<p>
Repetition is greedy by default: as many occurrences as possible are matched while still allowing the overall match to succeed. By contrast, lazy matching makes the minimal amount of matches necessary for overall success. A greedy metacharacter can be made lazy by following it with ?.
</p>
</blockquote>
</div>
</div>
<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">Match any of the 3 fields</h3>
<div class="outline-text-3" id="text-2-3">
<p>
How do we match any of the PII fields of <code>email</code>, <code>social_security_number</code>,
<code>date_of_birth</code>?
</p>

<p>
The answer is to use alternation.
</p>

<blockquote>
<p>
The vertical bar metacharacter (|) combines two expressions into a single one that matches either of the expressions. Each expression is an alternative.
</p>
</blockquote>


<pre class="example">
changed (email|social_security_number|date_of_birth) to &amp;quot;(.*?)&amp;quot;
</pre>

<p>
{% img /images/2015-01-25-masking-pii-with-ruby-gsub-with-regular-expression-named-match-groups/rubular-4.jpg %}
</p>
</div>
</div>
<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4">Experiment in the Console (Pry)</h3>
<div class="outline-text-3" id="text-2-4">
<p>
Open up your rails console (<code>rails c</code>) and paste the following 2 lines. This
will set you up with what we've been testing in Rubular.
</p>
{% codeblock lang:ruby %}
log_entry = "Updated User (4)<br>     changed first_name to &quot;Karina&quot;<br>     changed last_name to &quot;Senger&quot;<br>     changed phone to &quot;2133432154&quot;<br>     changed email to &quot;brenna.treutel@runolfsdottirdonnelly.org&quot;<br>     changed street to &quot;123 Main St&quot;<br>     changed city to &quot;Paia&quot;<br>     changed state to &quot;HI&quot;<br>     changed zip_code to &quot;96677&quot;<br>     changed social_security_number to &quot;555-33-4444&quot;<br>     changed date_of_birth to &quot;2000-10-03&quot;"
regexp = /changed (email|social_security_number|date_of_birth) to &quot;(.*?)&quot;/
{% endcodeblock %}

<p>
Then enter the following. Feel free to experiment!
</p>

{% codeblock lang:ruby %}
log_entry.match(regexp)
$~
$1
$2
$&
{% endcodeblock %}

<p>
Here's the doc of the globals set by a regexp. These are thread-local and
method-local variables. So they are safe in a multi-threaded environment.
</p>

<pre class="example">
Pattern matching sets some global variables :

$~ is equivalent to ::last_match;
$&amp; contains the complete matched text;
$` contains string before match;
$' contains string after match;
$1, $2 and so on contain text matching first, second, etc capture group;
$+ contains last capture group.
</pre>

<p>
{% img /images/2015-01-25-masking-pii-with-ruby-gsub-with-regular-expression-named-match-groups/pry-1.jpg %}
</p>


<p>
The <code>$~</code> will come in particularly handy when we try to use <code>gsub</code>.
</p>
</div>
</div>
<div id="outline-container-sec-2-5" class="outline-3">
<h3 id="sec-2-5">How Do We Get All the Matches?</h3>
<div class="outline-text-3" id="text-2-5">
<p>
<a href="http://ruby-doc.org/core-2.1.5/String.html#method-i-scan">String#scan</a> does it!
</p>

{% codeblock lang:ruby %}
log_entry.scan(regexp)
{% endcodeblock %}

<p>
{% img /images/2015-01-25-masking-pii-with-ruby-gsub-with-regular-expression-named-match-groups/pry-2.jpg %}
</p>
</div>
</div>
<div id="outline-container-sec-2-6" class="outline-3">
<h3 id="sec-2-6">Named Match Groups</h3>
<div class="outline-text-3" id="text-2-6">
<p>
<code>$1</code> and <code>$2</code> are not the most illuminating names for the capture group values. Ruby offers a way
to give them readable names. Quoting the Ruby doc for <a href="http://ruby-doc.org/core-2.1.5/Regexp.html">Class Regexp</a>:
</p>

<pre class="example">
Capture groups can be referred to by name when defined with the (?&lt;name&gt;) or (?'name') constructs.

/\$(?&lt;dollars&gt;\d+)\.(?&lt;cents&gt;\d+)/.match("$3.67")
    =&gt; #&lt;MatchData "$3.67" dollars:"3" cents:"67"&gt;
/\$(?&lt;dollars&gt;\d+)\.(?&lt;cents&gt;\d+)/.match("$3.67")[:dollars] #=&gt; "3"
Named groups can be backreferenced with \k&lt;name&gt;, where name is the group name.

/(?&lt;vowel&gt;[aeiou]).\k&lt;vowel&gt;.\k&lt;vowel&gt;/.match('ototomy')
    #=&gt; #&lt;MatchData "ototo" vowel:"o"&gt;
Note: A regexp can't use named backreferences and numbered backreferences simultaneously.

When named capture groups are used with a literal regexp on the left-hand side of an expression and the =~ operator, the captured text is also assigned to local variables with corresponding names.

/\$(?&lt;dollars&gt;\d+)\.(?&lt;cents&gt;\d+)/ =~ "$3.67" #=&gt; 0
dollars #=&gt; "3"
</pre>

<p>
Let's try that in rubular first by copying this regexp into rubular:
</p>

<pre class="example">
changed (?&lt;field&gt;email|social_security_number|date_of_birth) to &amp;quot;(?&lt;value&gt;.*?)&amp;quot;
</pre>

<p>
{% img /images/2015-01-25-masking-pii-with-ruby-gsub-with-regular-expression-named-match-groups/rubular-5.jpg %}
</p>

<p>
And then try this in the console:
</p>
{% codeblock lang:ruby %}
regexp_named_captures = /changed (?<field>email|social_security_number|date_of_birth) to &quot;(?<value>.*?)&quot;/
match_data = log_entry.match(regexp_named_captures)
match_data[:field]
match_data[:value]
log_entry.scan(regexp_named_captures)
arr[0]
arr[0][0]
{% endcodeblock %}

<p>
{% img /images/2015-01-25-masking-pii-with-ruby-gsub-with-regular-expression-named-match-groups/pry-3.jpg %}
</p>
</div>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">Substitution with <code>String#gsub</code></h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">Simple (Non-block) <code>String#gsub</code> Syntax</h3>
<div class="outline-text-3" id="text-3-1">
<p>
Now, back to the task at hand, which was to convert the original log entry with
PII so that the PII is redacted. We'll change the lines to something like this:
</p>

<pre class="example">
changed email to XXXXXX
</pre>

<p>
Let's take a look at the documentation for <a href="http://ruby-doc.org/core-2.1.5/String.html#method-i-replace">String#gsub</a>
</p>

<blockquote>
<p>
If replacement is a String it will be substituted for the matched text. It may contain back-references to the patternâ€™s capture groups of the form \\d, where d is a group number, or \\k&lt;n&gt;, where n is a group name. If it is a double-quoted string, both back-references must be preceded by an additional backslash. However, within replacement the special match variables, such as $&amp;, will not refer to the current match.
</p>
</blockquote>

{% codeblock lang:ruby %}
log_entry.gsub(regexp_named_captures, "changed \\k<field> to XXXXXX")
{% endcodeblock %}

<p>
And that results in mission accomplished!
{% img /images/2015-01-25-masking-pii-with-ruby-gsub-with-regular-expression-named-match-groups/pry-4.jpg %}
</p>
</div>
</div>
<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2">Block <code>String#gsub</code> Syntax</h3>
<div class="outline-text-3" id="text-3-2">
<p>
Suppose you want to use the block syntax of <code>String#gsub</code>. Given the use case in
this example, there's no particular reason to use it. However, you might come
across a use case where you'd like some logic in the bock to determine the
substitution value. Here's how you do it.
</p>

<blockquote>
<p>
In the block form, the current match string is passed in as a parameter, and variables such as $1, $2, $`, $&amp;, and $' will be set appropriately. The value returned by the block will be substituted for the match on each call.
</p>
</blockquote>

<p>
To use the block syntax with named capture groups is not exactly obvious.
</p>

<p>
You might think that the value passed into the block is the match data. Instead,
it's the full value of what was matched.
</p>

<p>
For example:
</p>

{% codeblock lang:ruby %}
log_entry.gsub(regexp_named_captures) { |match| "XXXXXX" }
{% endcodeblock %}

<p>
{% img /images/2015-01-25-masking-pii-with-ruby-gsub-with-regular-expression-named-match-groups/pry-5.jpg %}
</p>

<p>
That's not what we want. We want to show the field that was redacted.
</p>

<p>
Maybe we can use the same syntax as the non-block form:
</p>

{% codeblock lang:ruby %}
log_entry.gsub(regexp_named_captures) { |match| "changed \\k<field> to XXXXXX" }
{% endcodeblock %}

<p>
That doesn't work!
</p>

<p>
{% img /images/2015-01-25-masking-pii-with-ruby-gsub-with-regular-expression-named-match-groups/pry-6.jpg %}
</p>

<p>
The solution is that you have to use the globals mentioned above, like <code>$1</code>.
</p>

{% codeblock lang:ruby %}
log_entry.gsub(regexp_named_captures) { |match| "changed #{$1} to XXXXXX" }
{% endcodeblock %}

<p>
This works!
</p>

<p>
{% img /images/2015-01-25-masking-pii-with-ruby-gsub-with-regular-expression-named-match-groups/pry-7.jpg %}
</p>

<p>
But what if you want to use the named capture groups?
</p>

<p>
Then you have to use the <code>$~</code> which gives you the MatchData.
</p>

{% codeblock lang:ruby %}
log_entry.gsub(regexp_named_captures) { |match| "changed #{$~[:field]} to XXXXXX" }
{% endcodeblock %}

<p>
<b>Nice!</b> That works!
</p>

<p>
{% img /images/2015-01-25-masking-pii-with-ruby-gsub-with-regular-expression-named-match-groups/pry-8.jpg %}
</p>
</div>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">Summary of Key Lessons</h2>
<div class="outline-text-2" id="text-4">
<ol class="org-ol">
<li>The <a href="http://rubular.com/">rubular.com</a> site is super useful for testing regular expressions in Ruby.
</li>
<li>The Ruby console is awesome for testing the syntax using regular expressions
in Ruby, such as using the <code>String#match</code>, <code>String#scan</code>, and <code>String#gsub</code>
methods.
</li>
<li><code>String#match</code> only returns the first match, in the form of a <code>MatchData</code>
object. <code>String#scan</code> returns all matches, but the results come in the form
of Arrays of Arrays.   
</li>
<li><code>(.*)</code> matches greedily. <code>(.*?)</code> is non-greedy. Non-greedy stops at the first
possible place. Greedy goes to the last possible place. This is all within a
single line.
</li>
<li><code>(?&lt;some_name&gt;.*?)</code> is the syntax for a named capture group. Named capture groups
make your regular expressions easier to read.
</li>
<li>You can use a named capture group in your replacement value for a <code>String#gsub</code>
with the syntax <code>\\k&lt;some_name&gt;</code>. This is much more clear than <code>\\1</code>.
</li>
<li>If you use the block syntax for <code>String#gsub</code>, it does not work like the
non-block syntax in terms of substitution. You need to be aware of:
<ol class="org-ol">
<li>Value passed into the block is the full string matched, rather than a
MatchData object.
</li>
<li>The value returned from the block is what is substituted for the whole
string matched.
</li>
<li>The block is called once for each string matched.
</li>
<li>You have to use String interpolation within your code in the block, as
this is normal ruby code, unlike the String value in the non-block <code>gsub</code>
syntax. I.e., don't just return a String with <code>$1</code> inside of it. You need
to put <code>#{$1}</code> in the String.
</li>
<li>You can use the regexp globals like <code>$1</code> to access a capture group.
</li>
<li>To use a named capture group inside the block you need to use the
<code>$~[:some_name]</code> syntax, where <code>some_name</code> is the your named capture. You
will probably ignore the passed in argument to the <code>gsub</code> block if using
this syntax.
</li>
</ol>
</li>
</ol>
</div>
</div>
